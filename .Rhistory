xlab('')+
scale_color_manual(values = c('black'))+
geom_hline(yintercept = 0, linetype = 'dashed')+
geom_errorbar(aes(ymin=hpd_lower, ymax=hpd_higher), width=.1, position=dodge)+
coord_flip()+mytheme
p.mod1
load("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL2_CHAIN_1.RData")
# Extracting the pMCMC from summaries to add on the dat.R table
mod2.pmcmcs<- sapply(mods.R.RA.SPO,
get.pmcmc.from.summary,
predictor_variable = c('mean_relatedness','mean_relative_abundance', 'sporulation_score', 'log(nb_cds_not_involved_in_response)')) %>%
as.data.frame() %>%
mutate(predictor_variable = c('mean_relatedness', 'mean_relative_abundance', 'sporulation_score', 'log(nb_cds_not_involved_in_response)')) %>%
gather('cooperative_trait', 'pMCMC', 1:6) %>%
mutate(cooperative_trait = gsub('_no4', '', cooperative_trait)) %>%
mutate(response.predictor = paste0(cooperative_trait, '.', predictor_variable)) %>%
select(response.predictor, pMCMC)
get.pmcmc.from.posterior<- function(model){
relatedness.post<- mcmc(rowSums(model$VCV[,c(2,6)])/rowSums(model$VCV[,c(4,8)]))
genomeSize.post<- model$Sol[,grep('nb_cds_not_involved_in_response', colnames(model$Sol))]
pMCMC.relatedness<- (2*sum(relatedness.post<0))/length(relatedness.post)
pMCMC.genomeSize<- (2*sum(genomeSize.post<0))/length(genomeSize.post)
return(c(`Within host relatedness` = pMCMC.relatedness,
`Genome size` = pMCMC.genomeSize))
}
mod2.pmcmcs<- sapply(mods.R.UNCERTAINTY,
get.pmcmc.from.posterior) %>%
as.data.frame() %>%
rownames_to_column('predictor_variable') %>%
gather('cooperative_trait', 'pMCMC', 2:7) %>%
mutate(cooperative_trait = gsub('_no4', '', cooperative_trait)) %>%
mutate(response.predictor = paste0(cooperative_trait, '.', predictor_variable)) %>%
select(response.predictor, pMCMC)
dat.R.UNCERTAINTY.formatted<-
dat.R.UNCERTAINTY %>%
mutate(cooperative_trait = gsub('_no4', '', cooperative_trait)) %>%
mutate(response.predictor = paste0(cooperative_trait, '.', predictor_variable)) %>%
left_join(mod2.pmcmcs, by = 'response.predictor') %>%
select(predictor_variable, cooperative_trait, effect, sd_post, hpd_lower, hpd_higher, pMCMC) %>%
rename(`Predictor` = predictor_variable,
`Response` = cooperative_trait,
`Posterior mean` = effect,
`Posterior sd` = sd_post,
`HMP lower` = hpd_lower,
`HMP higher` = hpd_higher) %>%
mutate_if(is.numeric, funs(formatC(., digit = 3, format = 'f')))
# Format a table of Meta-analysis results for display
MA.MODELS_2.formatted<-
MA.MODELS_2 %>%
as.data.frame() %>%
mutate(predictor = gsub('Genome size', 'genome size', predictor)) %>%
rename(`Predictor` = predictor,
`Estimate` = estimate,
`Std. Error` = se,
`Z value` = z.value,
`P value` = p.value,
`CI lower` = ci.lower,
`CI upper` = ci.upper)
# Append meta-analysis output to model results output to get a common table used for plotting
ma.2.df<- data.frame(cooperative_trait = 'Meta-analysis',
effect = as.numeric(MA.MODELS_2[which(MA.MODELS_2[,1] == 'Within host relatedness'),'estimate']),
hpd_lower = as.numeric(MA.MODELS_2[which(MA.MODELS_2[,1] == 'Within host relatedness'),'ci.lower']),
hpd_higher = as.numeric(MA.MODELS_2[which(MA.MODELS_2[,1] == 'Within host relatedness'),'ci.upper']))
dat.R.UNCERTAINTY.relatedness<-
rbind(dat.R.UNCERTAINTY[dat.R.UNCERTAINTY$predictor_variable == 'Within host relatedness',c('cooperative_trait', 'effect', 'hpd_lower', 'hpd_higher')],
ma.2.df) %>%
mutate(cooperative_trait = gsub('_no4', '', cooperative_trait))
dat.R.UNCERTAINTY.relatedness$cooperative_trait <- factor(dat.R.UNCERTAINTY.relatedness$cooperative_trait, levels = c('secretome', 'secretion_system', 'biofilm', 'quorum_sensing', 'siderophores', 'ab_degradation', 'Meta-analysis'))
p.mod2<- ggplot(dat.R.UNCERTAINTY.relatedness, aes(x = cooperative_trait, y = effect))+
geom_point(position = dodge, size = 2)+
xlab('')+
scale_color_manual(values = c('black'))+
geom_hline(yintercept = 0, linetype = 'dashed')+
geom_errorbar(aes(ymin=hpd_lower, ymax=hpd_higher), width=.1, position=dodge)+
coord_flip()+mytheme
p.mod2
load("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL2_CHAIN_1.RData")
load("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_1.RData")
summary(m3)
mod3.summary.formatted<- format.summary(m3) %>%
mutate_if(is.numeric, funs(formatC(., digit = 3, format = 'f')))
mod3.summary.formatted
mod3.summary.formatted<- format.summary(m3) %>%
mutate_if(is.numeric, funs(formatC(., digit = 3, format = 'e')))
mod3.summary.formatted
mod3.summary.formatted<- format.summary(m3) %>%
mutate_if(is.numeric, funs(formatC(., digit = 2, format = 'e')))
load("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL4_CHAIN_1.RData")
# Extracting the pMCMC from summaries to add on the dat.R table
mod4.pmcmcs<- sapply(mods.R.RA.SPO,
get.pmcmc.from.summary,
predictor_variable = c('mean_relatedness','mean_relative_abundance', 'sporulation_score', 'log(nb_cds_not_involved_in_response)')) %>%
as.data.frame() %>%
mutate(predictor_variable = c('mean_relatedness', 'mean_relative_abundance', 'sporulation_score', 'log(nb_cds_not_involved_in_response)')) %>%
gather('cooperative_trait', 'pMCMC', 1:6) %>%
mutate(cooperative_trait = gsub('_no4', '', cooperative_trait)) %>%
mutate(response.predictor = paste0(cooperative_trait, '.', predictor_variable)) %>%
select(response.predictor, pMCMC)
# Format a table of models results for display in pdf
dat.R.RA.SPO.formatted<-
dat.R.RA.SPO %>%
mutate(response.predictor = paste0(cooperative_trait, '.', predictor_variable)) %>%
left_join(mod4.pmcmcs, by = 'response.predictor') %>%
select(predictor_variable, cooperative_trait, effect, sd_post, hpd_lower, hpd_higher, pMCMC) %>%
mutate(predictor_variable = gsub('nb_cds_not_involved_in_response', 'genome size', predictor_variable)) %>%
rename(`Predictor` = predictor_variable,
`Response` = cooperative_trait,
`Posterior mean` = effect,
`Posterior sd` = sd_post,
`HMP lower` = hpd_lower,
`HMP higher` = hpd_higher) %>%
mutate_if(is.numeric, funs(formatC(., digit = 3, format = 'f')))
# Format a table of Meta-analysis results for display
MA.MODELS_4.formatted<-
MA.MODELS_4 %>%
as.data.frame() %>%
mutate(predictor = gsub('nb_cds_not_involved_in_response', 'genome size', predictor)) %>%
rename(`Predictor` = predictor,
`Estimate` = estimate,
`Std. Error` = se,
`Z value` = z.value,
`P value` = p.value,
`CI lower` = ci.lower,
`CI upper` = ci.upper)
# Append meta-analysisoutput to model results output to get a common table used for plotting
ma.4.df<- data.frame(cooperative_trait = 'Meta-analysis',
effect = as.numeric(MA.MODELS_4[which(MA.MODELS_4[,1] %in% c('mean_relatedness', 'mean_relative_abundance', 'sporulation_score')),'estimate']),
hpd_lower = as.numeric(MA.MODELS_4[which(MA.MODELS_4[,1]  %in% c('mean_relatedness', 'mean_relative_abundance', 'sporulation_score')),'ci.lower']),
hpd_higher = as.numeric(MA.MODELS_4[which(MA.MODELS_4[,1]  %in% c('mean_relatedness', 'mean_relative_abundance', 'sporulation_score')),'ci.upper']),
predictor_variable = c('mean_relatedness', 'mean_relative_abundance', 'sporulation_score'))
dat.R.RA.SPO.relatedness<-
rbind(dat.R.RA.SPO[dat.R.RA.SPO$predictor_variable %in% c('mean_relatedness', 'mean_relative_abundance', 'sporulation_score'),c('cooperative_trait', 'effect', 'hpd_lower', 'hpd_higher', 'predictor_variable')],
ma.4.df)
dat.R.RA.SPO.relatedness$cooperative_trait <- factor(dat.R.RA.SPO.relatedness$cooperative_trait, levels = c('secretome', 'secretion_system', 'biofilm', 'quorum_sensing', 'siderophores', 'ab_degradation', 'Meta-analysis'))
dat.R.RA.SPO.relatedness$predictor_variable <- factor(dat.R.RA.SPO.relatedness$predictor_variable, levels = c('sporulation_score', 'mean_relative_abundance', 'mean_relatedness'))
p.mod4.1<- ggplot(dat.R.RA.SPO.relatedness %>% filter(predictor_variable == 'mean_relatedness'), aes(x = cooperative_trait, y = effect))+
geom_point(position = dodge, size = 2)+
xlab('')+
scale_color_manual(values = c('black'))+
geom_hline(yintercept = 0, linetype = 'dashed')+
geom_errorbar(aes(ymin=hpd_lower, ymax=hpd_higher), width=.1, position=dodge)+
coord_flip()+mytheme
p.mod4.2<- ggplot(dat.R.RA.SPO.relatedness, aes(x = cooperative_trait, y = effect, col = predictor_variable))+
geom_point(position = dodge, size = 2)+
xlab('')+
scale_color_manual(values = c('orange', 'dodgerblue', 'black'))+
geom_hline(yintercept = 0, linetype = 'dashed')+
geom_errorbar(aes(ymin=hpd_lower, ymax=hpd_higher), width=.1, position=dodge)+
coord_flip()+
theme_bw()+
theme(legend.position="top",
panel.border= element_blank(),
axis.text.y = element_text(face="bold", colour="black", size=10),
axis.text.x = element_text(face="bold", colour="black", size=11),
axis.title.y = element_text(face="bold", colour="black", size=11),
axis.title.x = element_text(face="bold", colour="black", size=11),
axis.line.y = element_line(color="black", size = 0.5),
axis.line.x = element_line(color="black", size = 0.5),
plot.title = element_text(lineheight=.8, face="bold", hjust = 0.5))
p.mod4.2
dat.R.RA.SPO.formatted
load("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL5_CHAIN_1.RData")
mod5.summary.formatted<- format.summary(m5) %>%
mutate_if(is.numeric, funs(formatC(., digit = 2, format = 'e')))
mod5.summary.formatted
mod5.summary.formatted<- format.summary(m5) %>%
mutate_if(is.numeric, funs(formatC(., digit = 2, format = 'f')))
mod5.summary.formatted
mod5.summary.formatted<- format.summary(m5) %>%
mutate_if(is.numeric, funs(formatC(., digit = 3, format = 'f')))
mod5.summary.formatted
mod5.summary.formatted<- format.summary(m5) %>%
mutate_if(is.numeric, funs(formatC(., digit = 3, format = 'e')))
mod5.summary.formatted
mod5.summary.formatted<- format.summary(m5) %>%
mutate_if(is.numeric, funs(formatC(., digit = 3, format = 'f')))
kable(mod5.summary.formatted, caption = "Cooperation, abundance and sporulation drivers of relatedness models summary", row.names = FALSE)
m5.joint.test
round(m5.joint.test, 3)
kable(round(m5.joint.test, 3), caption = "Cooperation traits joint test effect (wald test)", row.names = FALSE)
round(m5.joint.test, 3)
mod5.summary.formatted
MA.MODELS_4.formatted
data.frame(Chi2 = round(m5.joint.test, 3)[1],
df = round(m5.joint.test, 3)[2],
P value = round(m5.joint.test, 3)[3])
data.frame(Chi2 = round(m5.joint.test, 3)[1],
df = round(m5.joint.test, 3)[2],
`P value` = round(m5.joint.test, 3)[3])
m5.joint.test.formatted<- data.frame(Chi2 = round(m5.joint.test, 3)[1],
df = round(m5.joint.test, 3)[2],
`P value` = round(m5.joint.test, 3)[3])
kable(m5.joint.test.formatted, caption = "Cooperation traits joint test effect (wald test)", row.names = FALSE)
get.formula<- function(model){
fixed<- paste(as.character(model$Fixed$formula)[2],
as.character(model$Fixed$formula)[1],
as.character(model$Fixed$formula)[3],
sep = ' ')
random<- paste0(as.character(model$Random$formula), collapse = ' ')
resid<- paste0(as.character(model$Residual$formula), collapse = ' ')
return(list(fixed = fixed,
random = random,
resid = resid))
}
get.formula(mods.R$secretome)
get.formula(mods.R.UNCERTAINTY$secretome)
get.formula(m3)
get.formula(mods.R.RA.SPO$secretome)
get.formula(m5)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(tidy = TRUE)
source("~/Documents/PhD/Research/background_scripts/basic_packages.R")
source("~/Documents/PhD/Research/background_scripts/ggplot_themes.R")
# DEFINING SOME FUNCTIONS TO BE USED IN THIS SCRIPT
get.pmcmc.from.summary<- function(model, predictor_variable){
return(as.data.frame(summary(model)$solutions)[predictor_variable,'pMCMC'])
}
dodge = position_dodge(width = 0.3, preserve = c("total", "single"))
get.formula<- function(model){
fixed<- paste(as.character(model$Fixed$formula)[2],
as.character(model$Fixed$formula)[1],
as.character(model$Fixed$formula)[3],
sep = ' ')
random<- paste0(as.character(model$Random$formula), collapse = ' ')
resid<- paste0(as.character(model$Residual$formula), collapse = ' ')
return(list(fixed = fixed,
random = random,
resid = resid))
}
format.summary<- function(model_output){
df<-
summary(model_output)$solutions %>%
as.data.frame()%>%
rownames_to_column('Predictor') %>%
rename(`Posterior mean` = post.mean,
`CI lower` = `l-95% CI`,
`CI upper` = `u-95% CI`,
`Effective Sampling` = eff.samp)
return(df)
}
# Clear and re-load environment everytime because otherwise this is too big to load
library("R.utils")
remove(list = ls())
run_gelman_rubin_test<- function(chains, model_id){
Sol.chains<- vector('list', length = length(chains))
vcv.chains<- vector('list', length = length(chains))
for(i in 1:length(chains)){
Sol.chains[[i]]<- chains[[i]][[model_id]]$Sol
vcv.chains[[i]]<- chains[[i]][[model_id]]$VCV
}
sol.psrd<- gelman.diag(mcmc.list(Sol.chains))$psrf[,2]
vcv.psrd<- gelman.diag(mcmc.list(vcv.chains))$psrf[,2]
gelman_results<- data.frame(model_id = model_id,
fixed.effects.max.upperCI.psrf = max(sol.psrd),
vcv.effects.max.upperCI.psrf = max(vcv.psrd))
return(gelman_results)
}
# GR-test on model 1
mods.R.chain1 <- load("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL1_CHAIN_1.RData")
mods.R.chain2 <- load("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL1_CHAIN_2.RData")
mods.R.chains<- list(mods.R.chain1, mods.R.chain2)
gr.test.model1<-
rbind(
run_gelman_rubin_test(mods.R.chains, 'secretome'),
run_gelman_rubin_test(mods.R.chains, 'ab_degradation'),
run_gelman_rubin_test(mods.R.chains, 'biofilm'),
run_gelman_rubin_test(mods.R.chains, 'secretion_system_no4'),
run_gelman_rubin_test(mods.R.chains, 'siderophores'),
run_gelman_rubin_test(mods.R.chains, 'quorum_sensing')) %>%
mutate(model = 'model 1')
library("R.utils")
remove(list = ls())
run_gelman_rubin_test<- function(chains, model_id){
Sol.chains<- vector('list', length = length(chains))
vcv.chains<- vector('list', length = length(chains))
for(i in 1:length(chains)){
Sol.chains[[i]]<- chains[[i]][[model_id]]$Sol
vcv.chains[[i]]<- chains[[i]][[model_id]]$VCV
}
sol.psrd<- gelman.diag(mcmc.list(Sol.chains))$psrf[,2]
vcv.psrd<- gelman.diag(mcmc.list(vcv.chains))$psrf[,2]
gelman_results<- data.frame(model_id = model_id,
fixed.effects.max.upperCI.psrf = max(sol.psrd),
vcv.effects.max.upperCI.psrf = max(vcv.psrd))
return(gelman_results)
}
# GR-test on model 1
mods.R.chain1 <- load("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL1_CHAIN_1.RData")[['mods.R']]
# Clear and re-load environment everytime because otherwise this is too big to load
library("R.utils")
remove(list = ls())
run_gelman_rubin_test<- function(chains, model_id){
Sol.chains<- vector('list', length = length(chains))
vcv.chains<- vector('list', length = length(chains))
for(i in 1:length(chains)){
Sol.chains[[i]]<- chains[[i]][[model_id]]$Sol
vcv.chains[[i]]<- chains[[i]][[model_id]]$VCV
}
sol.psrd<- gelman.diag(mcmc.list(Sol.chains))$psrf[,2]
vcv.psrd<- gelman.diag(mcmc.list(vcv.chains))$psrf[,2]
gelman_results<- data.frame(model_id = model_id,
fixed.effects.max.upperCI.psrf = max(sol.psrd),
vcv.effects.max.upperCI.psrf = max(vcv.psrd))
return(gelman_results)
}
# GR-test on model 1
mods.R.chain1 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL1_CHAIN_1.RData")[[c('mods.R')]]
mods.R.chain2 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL1_CHAIN_2.RData")[[c('mods.R')]]
mods.R.chains<- list(mods.R.chain1, mods.R.chain2)
gr.test.model1<-
rbind(
run_gelman_rubin_test(mods.R.chains, 'secretome'),
run_gelman_rubin_test(mods.R.chains, 'ab_degradation'),
run_gelman_rubin_test(mods.R.chains, 'biofilm'),
run_gelman_rubin_test(mods.R.chains, 'secretion_system_no4'),
run_gelman_rubin_test(mods.R.chains, 'siderophores'),
run_gelman_rubin_test(mods.R.chains, 'quorum_sensing')) %>%
mutate(model = 'model 1')
rm(list = c("mods.R.chain1",
"mods.R.chain2",
#"mods.R.chain3",
"mods.R.chains"))
loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_1.RData")[[c('m3')]]
# GR-test on model 3
model3.chain1 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_1.RData")[[c('m3')]]
mods.R.chain2 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_2.RData")[[c('mods.R')]]
rm(list = c("model3.chain1",
"model3.chain2",
#"model3.chain3",
"model3.chains"))
# GR-test on model 4
mods.R.RA.SPO.chain1 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL4_CHAIN_1.RData")[[c('mods.R.RA.SPO')]]
mods.R.RA.SPO.chain2 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL4_CHAIN_2.RData")[[c('mods.R.RA.SPO')]]
mods.R.RA.SPO.chains<- list(mods.R.RA.SPO.chain1, mods.R.RA.SPO.chain2)
gr.test.model4<-
rbind(
run_gelman_rubin_test(mods.R.RA.SPO.chains, 'secretome'),
run_gelman_rubin_test(mods.R.RA.SPO.chains, 'ab_degradation'),
run_gelman_rubin_test(mods.R.RA.SPO.chains, 'biofilm'),
run_gelman_rubin_test(mods.R.RA.SPO.chains, 'secretion_system_no4'),
run_gelman_rubin_test(mods.R.RA.SPO.chains, 'siderophores'),
run_gelman_rubin_test(mods.R.RA.SPO.chains, 'quorum_sensing')) %>%
mutate(model = 'model 4')
rm(list = c("mods.R.RA.SPO.chain1",
"mods.R.RA.SPO.chain2",
#"mods.R.RA.SPO.chain3",
"mods.R.RA.SPO.chains"))
# GR-test on model 5
mods.5.chain1 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL5_CHAIN_1.RData")[[c('m5')]]
mods.5.chain2 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL5_CHAIN_2.RData")[[c('m5')]]
# GR-test on model 3
model3.chain1 <- loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_1.RData")[[c('m3')]]
model3.chain1<- list(model_3 = loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_1.RData")[[c('m3')]])
mods.R.chain2 <- list(model_3 = loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_1.RData")[[c('m3')]])
model3.chain2 <- list(model_3 = loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_2.RData")[[c('m3')]])
model3.chain2 <- list(model_3 = loadToEnv("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_1.RData")[[c('m3')]])
model3.chains<- list(model3.chain1, model3.chain2)
gr.test.model3<- run_gelman_rubin_test(model3.chains, 'model_3') %>%
mutate(model = 'model 3')
gr.test.model3
chains = model3.chains
model_id = 'model_3'
length(chains)
Sol.chains<- vector('list', length = length(chains))
vcv.chains<- vector('list', length = length(chains))
i=1
chains[[i]][[model_id]]$Sol
Sol.chains[[i]]<- chains[[i]][[model_id]]$Sol
vcv.chains[[i]]<- chains[[i]][[model_id]]$VCV
Sol.chains<- vector('list', length = length(chains))
vcv.chains<- vector('list', length = length(chains))
for(i in 1:length(chains)){
Sol.chains[[i]]<- chains[[i]][[model_id]]$Sol
vcv.chains[[i]]<- chains[[i]][[model_id]]$VCV
}
sol.psrd<- gelman.diag(mcmc.list(Sol.chains))$psrf[,2]
vcv.psrd<- gelman.diag(mcmc.list(vcv.chains))$psrf[,2]
gelman.diag(mcmc.list(Sol.chains))
setwd("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_gitRepos/")
source("~/Documents/PhD/Research/background_scripts/basic_packages.R")
# PREP DATA ----
# d: full dataset, to use for models using within host values, i.e. (#2) uncertainty model and (#3) drivers of relatedness
# d_109: same as d but to use when having secretome size as response. We remove species for which gram profile could not be determined and thus psortB could not be run.
# d_mean: relatedness and abundance averaged by species, for model (#1) and (#4)
# d_mean_109: same as d_mean but to use for the model where secretome size is the response
d<- read.table('/Users/s1687811/Documents/GitHub/HamiltonRuleMicrobiome/output/ANALYSIS_DATA_ASSEMBLED.txt', header=TRUE, stringsAsFactors = FALSE) %>% mutate(first = !duplicated(species_id)) %>% rename(species = species_id)
toremove<- unique(d[d$gram_profile == 'gram0','species'])
d_109<- d %>% filter(!is.element(species, toremove)) %>% as.data.frame()
d_mean<- d %>%
group_by(species) %>%
mutate(mean_relative_abundance = mean(within_host_relative_abundance)) %>%
select(-host, -within_host_relatedness, -within_host_relative_abundance) %>%
subset(first == TRUE) %>%
ungroup() %>%
as.data.frame()
d_mean_109<- d_mean %>% filter(!is.element(species, toremove)) %>% as.data.frame()
# PHYLOGENY
library("ape")
library('MCMCglmm')
midas.tree<- read.tree('~/Documents/GitHub/HamiltonRuleMicrobiome/data/species_info_files/midas_tree_renamed.newick')
phylogeny<- drop.tip(midas.tree, midas.tree$tip.label[which(!is.element(midas.tree$tip.label, d_mean$species))])
phylogeny<- chronopl(phylogeny, lambda = 0)
phylogeny<-makeNodeLabel(phylogeny)
phylogeny_109<- drop.tip(phylogeny, phylogeny$tip.label[which(phylogeny$tip.label %in% toremove)])
phylogeny<-makeNodeLabel(phylogeny)
phylogeny_109<-makeNodeLabel(phylogeny_109)
Ainv<-inverseA(phylogeny, scale=FALSE)$Ainv
Ainv_109<-inverseA(phylogeny_109, scale=FALSE)$Ainv
nitt<-1005000
burnin<-5000
thin<-50
d$species.ide<-d$species
dm3<- d[,c('species', 'host', 'within_host_relatedness', 'species.ide', 'sporulation_score', 'within_host_relative_abundance')]
# We use a parameter expanded prior
prior.0.expanded<- list(R=list(V = diag(1), nu = 0.002),
G=list(
G1=list(V= 1, nu= 1, alpha.mu= 0, alpha.V= 1000),
G2=list(V= 1, nu= 1, alpha.mu= 0, alpha.V= 1000),
G3=list(V= 1, nu= 1, alpha.mu= 0, alpha.V= 1000)
))
m3<- MCMCglmm(within_host_relatedness ~ 1 + sporulation_score + within_host_relative_abundance,
random = ~species.ide+host+species,
ginverse = list(species=Ainv),
data = dm3, prior=prior.0.expanded,
family=c("gaussian"),
#start=list(QUASI=FALSE),
pl = TRUE, nodes = 'ALL', nitt=nitt, thin=thin, burnin=burnin)
summary(m3)
#save.image('~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_1.RData')
save.image('~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL3_CHAIN_2.RData')
print('section 3 done!')
setwd("~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_gitRepos/")
source("~/Documents/PhD/Research/background_scripts/basic_packages.R")
# PREP DATA ----
# d: full dataset, to use for models using within host values, i.e. (#2) uncertainty model and (#3) drivers of relatedness
# d_109: same as d but to use when having secretome size as response. We remove species for which gram profile could not be determined and thus psortB could not be run.
# d_mean: relatedness and abundance averaged by species, for model (#1) and (#4)
# d_mean_109: same as d_mean but to use for the model where secretome size is the response
d<- read.table('/Users/s1687811/Documents/GitHub/HamiltonRuleMicrobiome/output/ANALYSIS_DATA_ASSEMBLED.txt', header=TRUE, stringsAsFactors = FALSE) %>% mutate(first = !duplicated(species_id)) %>% rename(species = species_id)
toremove<- unique(d[d$gram_profile == 'gram0','species'])
d_109<- d %>% filter(!is.element(species, toremove)) %>% as.data.frame()
d_mean<- d %>%
group_by(species) %>%
mutate(mean_relative_abundance = mean(within_host_relative_abundance)) %>%
select(-host, -within_host_relatedness, -within_host_relative_abundance) %>%
subset(first == TRUE) %>%
ungroup() %>%
as.data.frame()
d_mean_109<- d_mean %>% filter(!is.element(species, toremove)) %>% as.data.frame()
# PHYLOGENY
library("ape")
library('MCMCglmm')
midas.tree<- read.tree('~/Documents/GitHub/HamiltonRuleMicrobiome/data/species_info_files/midas_tree_renamed.newick')
phylogeny<- drop.tip(midas.tree, midas.tree$tip.label[which(!is.element(midas.tree$tip.label, d_mean$species))])
phylogeny<- chronopl(phylogeny, lambda = 0)
phylogeny<-makeNodeLabel(phylogeny)
phylogeny_109<- drop.tip(phylogeny, phylogeny$tip.label[which(phylogeny$tip.label %in% toremove)])
phylogeny<-makeNodeLabel(phylogeny)
phylogeny_109<-makeNodeLabel(phylogeny_109)
Ainv<-inverseA(phylogeny, scale=FALSE)$Ainv
Ainv_109<-inverseA(phylogeny_109, scale=FALSE)$Ainv
nitt<-1005000
burnin<-5000
thin<-50
d_109$species.ide<-d_109$species
# We use a parameter expanded prior
prior.0.expanded<- list(R=list(V = diag(1), nu = 0.002),
G=list(
G1=list(V= 1, nu= 1, alpha.mu= 0, alpha.V= 1000),
G2=list(V= 1, nu= 1, alpha.mu= 0, alpha.V= 1000),
G3=list(V= 1, nu= 1, alpha.mu= 0, alpha.V= 1000)
))
# We can use the same prior, nitt, burnin and thin. Simply has two main effect added in (for which default prior is used)
m5<- MCMCglmm(within_host_relatedness ~ 1 + sporulation_score + within_host_relative_abundance + biofilm + ab_degradation + quorum_sensing + siderophores + secretion_system_no4 + nb_extracellular,
random = ~species.ide+host+species,
ginverse = list(species=Ainv),
data = d_109, prior=prior.0.expanded,
family=c("gaussian"),
#start=list(QUASI=FALSE),
pl = TRUE, nodes = 'ALL', nitt=nitt, thin=thin, burnin=burnin)
summary(m5)
add.cor.title<- function(y, x, n){
y2 = y[sample(x = seq(1:length(y)), size = n, replace = FALSE)]
x2 = x[sample(x = seq(1:length(x)), size = n, replace = FALSE)]
cor = cor.test(y = y2, x = x2)
mtext(side = 3,
paste0('cor = ', formatC(cor[[4]], digit = 3, format = 'f'), ' p = ', formatC(cor[[3]], digit = 3, format = 'f')),
col = ifelse(cor[[3]] < 0.05, 'red', 'black'))
abline(h = 0, v = 0, lty = 2, col = "grey")
}
foo<- m5$Sol %>% as.data.frame()
m5.joint.test<- aod::wald.test(cov(m5$Sol), colMeans(m5$Sol), Terms=4:9)$result$chi2
#save.image('~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL5_CHAIN_1.RData')
save.image('~/Documents/PhD/Research/HamiltonRuleMicrobiome/HamiltonRuleMicrobiome_work/output/MODEL5_CHAIN_2.RData')
print("section 5 done :)")
d_109$mean_relatedness
min(d_109$mean_relatedness)
which.min(d_109$mean_relatedness)
which.min(d_mean_109$mean_relatedness)
min(d_mean_109$mean_relatedness)
d_mean_109[which.min(d_mean_109$mean_relatedness),]
ggplot(d_mean_109 %>% filter(firs == TRUE), aes(mean_relatedness))+
geom_density()
ggplot(d_mean_109 %>% filter(first == TRUE), aes(mean_relatedness))+
geom_density()
d_mean_109[which.max(d_mean_109$mean_relatedness),]
exp(0.59 + 0.93)/exp(0.59 + 0.12)
exp(0.59 + 0.93)/exp(0.59 + 0.12)
exp(0.59*0.93)/exp(0.59*0.12)
exp((0.59*0.93)+0.1)/exp((0.59*0.12) + 0.1)
length(unique(d_109$host))
